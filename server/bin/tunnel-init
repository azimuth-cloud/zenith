#!/usr/bin/env python3

import json
import sys

####
# This script runs when a user connects over SSH, and is responsible for
# mapping a subdomain to the port for a reverse SSH tunnel.
#
# The client specifies the bound port and subdomain using stdin.
#
# We would prefer to detect the bound port for the tunnel on this side but
# doing this reliably might be impossible, and is certainly very difficult
# and probably requires root.
#
# To get round this, the client reads the tunnel's dynamically-allocated port
# from stderr and pushes it back via stdin along with the subdomain.
#
# This obviously places a lot of trust in a client to specify the SSH
# connection correctly, and also to specify the actual port it was allocated
# rather than a different port that another service may be connected to.
#
# We mitigate against this in a number of ways:
#
#   1. Only allow the execution of this script over the SSH connection. This
#      limits the ability of a nefarious client to collect information about
#      other tunnels connected to the system and their ports.
#
#   2. Encourage clients to use dynamically-allocated ports. This makes the
#      port for a service more difficult to guess and so harder to connect
#      to for nefarious purposes.
#
#   3. Encourage clients to use subdomains that are hard to guess.
#      This makes it more difficult for a nefarious client to discover a valid
#      domain and bind to it.
#
#   4. Only allow ports to be bound to localhost. This prevents a nefarious user
#      from accessing the bound port directly, bypassing the proxy and any
#      associated authentication.
#
#   5. Only allow reverse port-forwarding, not regular port-forwarding. This
#      prevents a nefarious client from setting up a regular port-foward to
#      the bound port for another service and sending traffic directly to it,
#      bypassing the proxy and any associated authentication.
#
#   6. Only map the given subdomain to the given port if the subdomain is not
#      already mapped to another port. This prevents a nefarious client from
#      hijacking another service's domain and pointing it at its connected port.
#
#   7. Only map the given subdomain to the given port if the port is not
#      already associated with another subdomain. This prevents a nefarious client
#      from pointing a second, known subdomain at the port for another client.
#
# CORRECT USAGE
#
# The correct usage of this tunnel server would look something like:
#
#   $ ssh -t -o ExitOnForwardFailure=yes -R 0:localhost:8000 tunnel@<tunnelhost>
#   [stderr] Allocated port 43627 for remote forward to localhost:8000
#   [stdout] Reading configuration from stdin...
#   [stdout] SET_PORT
#   [STDIN]  43627
#   [stdout] SET_SUBDOMAIN
#   [STDIN]  b103b6ae7f13d66d4fedeac0794160ca
#
# This would allocate the specified subdomain to the bound port.
#
# ATTEMPTING TO SEND UNAUTHENTICATED TRAFFIC DOWN A REGULAR PORT-FORWARD
#
# If a nefarious client wanted to send traffic directly to the above service and
# not via the proxy in order to bypass authentication, and was able to discover
# the bound port number, they might try something like:
#
#          Try to open a forwarded port to the service's port
#                                |
#   $ ssh -N -L 5000:localhost:43627 tunnel@<tunnelhost>
#
# However any attempt to send traffic down this tunnel results in multiple
# messages like the following, and a reset connection:
#
#   channel 3: open failed: administratively prohibited: open failed
#   channel 4: open failed: administratively prohibited: open failed
#   ...
#
# ATTEMPTING TO HIJACK A DOMAIN
#
# If a nefarious client is able to discover the domain for an already-connected
# service and wants to hijack that subdomain and bind it to their own port, they
# might try something like:
#
#   $ ssh -t -R 0:localhost:8000 tunnel@<tunnelhost>
#   [stderr] Allocated port 45775 for remote forward to localhost:8000
#   [stdout] Reading configuration from stdin...
#   [stdout] SET_PORT
#   [STDIN]  45775
#   [stdout] SET_SUBDOMAIN
#   [STDIN]  b103b6ae7f13d66d4fedeac0794160ca    <-- specify the subdomain to hijack
#
# This would be rejected because the subdomain is already bound to another port.
#
# ATTEMPTING TO BIND A SECOND DOMAIN TO ANOTHER SERVICE
#
# If a nefarious client is able to discover the bound port for a service and
# wants to bind a second subdomain to that service that is known to them, they
# might try something like:
#
#   $ ssh -t -R 0:localhost:8000 tunnel@<tunnelhost>
#   [stderr] Allocated port 39101 for remote forward to localhost:8000
#   [stdout] Reading configuration from stdin...
#   [stdout] SET_PORT
#   [STDIN]  43627    <-- specify the port for the target, not the allocated port
#   [stdout] SET_SUBDOMAIN
#   [STDIN]  mysubdomain    <-- specify a known subdomain
#
# This would be rejected because the port is already bound to another subdomain.
####


def parse_port(input):
    """
    Attempts to parse the given input as a port
    """
    return input


def parse_subdomain(input):
    """
    Attempts to parse the given input as a subdomain.
    """
    return input


def get_config_item(item):
    # Send the marker to request that the client send the config item
    print(f"SET_{item}")
    return input()


print("Reading configuration from stdin...")

# Use a request/response mechanism to request that the client sends config
print("SET_PORT")
port = parse_port(input())
print("SET_SUBDOMAIN")
subdomain = parse_subdomain(input())

print(f"Mapping subdomain '{subdomain}' to port {port}...")

while True:
    pass
