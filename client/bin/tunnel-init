#!/usr/bin/env python3

import contextlib
import dataclasses
import json
import os
import random
import re
import signal
import string
import subprocess
import sys
import typing


@dataclasses.dataclass
class Config:
    """
    Class representing the configuration of the tunnel client.
    """
    #: The SSH executable to use
    ssh_executable: str
    #: Configure timeout
    tunnel_configure_timeout: int
    #: The tunnel server to connect to
    tunnel_server: str
    #: The tunnel server SSH port
    tunnel_server_port: int
    #: The host to forward tunnel traffic to
    forward_to_host: str
    #: The port to forward tunnel traffic to
    forward_to_port: int
    #: The subdomain to request
    #: If not given, a random subdomain is used
    subdomain: typing.Optional[str]


def get_config_from_env():
    """
    Returns a config object built from the environment variables.
    """
    if 'SUBDOMAIN' in os.environ:
        subdomain = os.environ['SUBDOMAIN']
    else:
        subdomain = "".join(random.choices(string.ascii_letters + string.digits, k = 32))
    return Config(
        ssh_executable = os.environ.get('SSH_EXECUTABLE', 'ssh'),
        # Default to a 5s timeout
        tunnel_configure_timeout = int(os.environ.get('TUNNEL_CONFIGURE_TIMEOUT', '5')),
        tunnel_server = os.environ['TUNNEL_SERVER'],
        tunnel_server_port = os.environ.get('TUNNEL_SERVER_PORT', '22'),
        forward_to_host = os.environ.get('FORWARD_TO_HOST', 'localhost'),
        forward_to_port = os.environ.get('FORWARD_TO_PORT', '8000'),
        subdomain = subdomain
    )


def get_allocated_port(output):
    """
    Extract the allocated port from the output stream.
    """
    for line in output:
        line = line.rstrip()
        match = re.match(r"Allocated port (?P<port>\d+) for remote forward", line)
        if match is not None:
            return int(match.group('port'))
        else:
            # If the line is not the one we need, send it to stderr
            print(line, file = sys.stderr)
    else:
        print("[CLIENT] [ERROR] No port received from server", file = sys.stderr)
        sys.exit(1)


def wait_for_marker(output, marker):
    """
    Waits for the given marker to appear on the output stream before returning.
    """
    for line in output:
        line = line.rstrip()
        if line == marker:
            break
        else:
            # If the line is not the one we need, send it to stdout
            print(line)
    else:
        print(f"[CLIENT] [ERROR] Unable to find marker '{marker}'", file = sys.stderr)
        sys.exit(1)


def raise_timeout_error(signum, frame):
    """
    Utility function to raise a timeout error, used as a signal handler for the alarm signal.
    """
    raise TimeoutError


@contextlib.contextmanager
def timeout(seconds):
    """
    Context manager / decorator that imposes a timeout on the wrapped code.
    """
    previous = signal.signal(signal.SIGALRM, raise_timeout_error)
    signal.alarm(seconds)
    try:
        yield
    finally:
        signal.alarm(0)
        signal.signal(signal.SIGALRM, previous)


def configure_tunnel(ssh_proc, config):
    """
    Configures the tunnel.
    """
    # If the server is behaving correctly configuring the tunnel should be quick,
    # so we should time out if it takes too long
    try:
        with timeout(config.tunnel_configure_timeout):
            # Get the dynamically allocated port from the SSH process
            # This is received on stdout, but we have configured the process to send
            # stderr to stdout
            allocated_port = get_allocated_port(ssh_proc.stdout)
            # Build the config object
            tunnel_config = dict(
                allocated_port = allocated_port,
                subdomain = config.subdomain
            )
            # The server will ask for the config when it is ready
            wait_for_marker(ssh_proc.stdout, "SEND_CONFIGURATION")
            # Then we send a JSON-encoded version of the configuration
            json.dump(tunnel_config, ssh_proc.stdin)
            # We need to send a newline to trigger the read on the server
            print("", file = ssh_proc.stdin)
            # Indicate that we have sent all the configuration that we will send
            print("END_CONFIGURATION", file = ssh_proc.stdin)
            ssh_proc.stdin.flush()
            #Â Wait for the server to confirm that it received the config
            wait_for_marker(ssh_proc.stdout, "RECEIVED_CONFIGURATION")
            print("[CLIENT] [INFO] Tunnel configured successfully")
    except TimeoutError:
        print(
            "[CLIENT] [ERROR] Timed out negotiating tunnel configuration",
            file = sys.stderr
        )
        # Terminate the SSH process before exiting
        ssh_proc.terminate()
        sys.exit(1)


def forward_stream(input, output):
    """
    Reads input from the input stream and writes it to the output stream.
    """
    for line in input:
        print(line, file = output)


def main():
    """
    Entry point for the script.
    """
    # Build the config object from the environment
    config = get_config_from_env()

    # Derive the SSH command to use from the configuration
    ssh_command = [
        config.ssh_executable,
        # Force a TTY so that we can send data over stdin
        "-tt",
        # Exit immediately if the port forwarding fails
        "-o",
        "ExitOnForwardFailure=yes",
        # Ignore host keys (for now)
        "-o",
        "StrictHostKeyChecking=no",
        "-o",
        "UserKnownHostsFile=/dev/null",
        # Use a dynamically allocated port
        "-R",
        f"0:{config.forward_to_host}:{config.forward_to_port}",
        # Configure the tunnel server
        "-p",
        config.tunnel_server_port,
        f"tunnel@{config.tunnel_server}",
    ]

    print(f"[CLIENT] [INFO] Spawning SSH - {' '.join(ssh_command)}")

    # Open the SSH process
    ssh_proc = subprocess.Popen(
        ssh_command,
        text = True,
        stdin = subprocess.PIPE,
        stdout = subprocess.PIPE,
        # Send stderr to the same handler as stdout
        stderr = subprocess.STDOUT
    )

    print("[CLIENT] [INFO] Preparing to negotiate tunnel configuration...")

    configure_tunnel(ssh_proc, config)

    # Just forward stdout (which contains stderr) until the process exits
    for line in ssh_proc.stdout:
        print(line.rstrip())

    # Belt and braces to make sure the process has definitely terminated
    ssh_proc.wait()

    if ssh_proc.returncode == 0:
        print("[CLIENT] [INFO] SSH process exited without an error")
    else:
        print(
            f"[CLIENT] [WARNING] SSH process exited with non-zero exit code ({ssh_proc.returncode})",
            file = sys.stderr
        )

    # Exit with the returncode from the SSH command
    sys.exit(ssh_proc.returncode)


if __name__ == "__main__":
    main()
