#!/usr/bin/env python3

import asyncio
import dataclasses
import os
import random
import re
import string
import sys
import typing


@dataclasses.dataclass
class Config:
    """
    Class representing the configuration of the tunnel client.
    """
    #: The SSH executable to use
    ssh_executable: str
    #: Configure timeout
    tunnel_configure_timeout: int
    #: The tunnel server to connect to
    tunnel_server: str
    #: The tunnel server SSH port
    tunnel_server_port: int
    #: The host to forward tunnel traffic to
    forward_to_host: str
    #: The port to forward tunnel traffic to
    forward_to_port: int
    #: The subdomain to request
    #: If not given, a random subdomain is used
    subdomain: typing.Optional[str]


def parse_host(input):
    """
    Attempts to parse the given input as a hostname or IP.
    """
    return input


def parse_port(input):
    """
    Attempts to parse the given input as a port
    """
    return input


def parse_subdomain(input):
    """
    Attempts to parse the given input as a subdomain.
    """
    return input


def generate_subdomain():
    """
    Generates a random subdomain.
    """
    return "".join(random.choices(string.ascii_letters + string.digits, k = 32))


def get_config_from_env():
    """
    Returns a config object built from the environment variables.
    """
    if 'SUBDOMAIN' in os.environ:
        subdomain = parse_subdomain(os.environ['SUBDOMAIN'])
    else:
        subdomain = generate_subdomain()
    return Config(
        ssh_executable = os.environ.get('SSH_EXECUTABLE', 'ssh'),
        # Default to a 5s timeout
        tunnel_configure_timeout = int(os.environ.get('TUNNEL_CONFIGURE_TIMEOUT', '5')),
        tunnel_server = parse_host(os.environ['TUNNEL_SERVER']),
        tunnel_server_port = parse_port(os.environ.get('TUNNEL_SERVER_PORT', '22')),
        forward_to_host = parse_host(os.environ.get('FORWARD_TO_HOST', 'localhost')),
        forward_to_port = parse_port(os.environ.get('FORWARD_TO_PORT', '8000')),
        subdomain = subdomain
    )


async def get_allocated_port(ssh_proc):
    """
    Extract the allocated port from stderr.
    """
    while not ssh_proc.stderr.at_eof():
        line = (await ssh_proc.stderr.readline()).decode()
        match = re.match(r"Allocated port (?P<port>\d+) for remote forward", line)
        if match is not None:
            return int(match.group('port'))
        else:
            # If the line is not the one we need, send it to stderr
            sys.stderr.write(line)
            sys.stderr.flush()


async def wait_for_marker(stream, marker):
    """
    Waits for the given marker to appear on the given stream before returning.
    """
    while not stream.at_eof():
        line = (await stream.readline()).decode()
        if line.strip() == marker:
            break
        else:
            # If the line is not the one we need, send it to stdout
            sys.stdout.write(line)
            sys.stdout.flush()


async def configure_tunnel(ssh_proc, config):
    """
    Configures the tunnel.
    """
    # Get the dynamically allocated port from the SSH process
    allocated_port = await get_allocated_port(ssh_proc)
    # The server will ask for the port and then the subdomain
    await wait_for_marker(ssh_proc.stdout, "SET_PORT")
    ssh_proc.stdin.write(f"{allocated_port}\n".encode())
    await ssh_proc.stdin.drain()
    await wait_for_marker(ssh_proc.stdout, "SET_SUBDOMAIN")
    ssh_proc.stdin.write(f"{config.subdomain}\n".encode())
    await ssh_proc.stdin.drain()
    await wait_for_marker(ssh_proc.stdout, "CONFIGURATION_COMPLETE")


async def main():
    """
    Entry point for the script.
    """
    # Build the config object from the environment
    config = get_config_from_env()

    # Derive the SSH command to use from the configuration
    ssh_command = ' '.join([
        config.ssh_executable,
        # Force a TTY so that we can send data over stdin
        "-tt",
        # Exit immediately if the port forwarding fails
        "-o ExitOnForwardFailure=yes",
        # Ignore host keys (for now)
        "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null",
        # Use a dynamically allocated port
        f"-R 0:{config.forward_to_host}:{config.forward_to_port}",
        # Configure the tunnel server
        f"-p {config.tunnel_server_port} tunnel@{config.tunnel_server}"
    ])

    print(f"[CLIENT] [INFO] Spawning SSH - {ssh_command}")

    # Open the SSH process
    ssh_proc = await asyncio.create_subprocess_shell(
        ssh_command,
        stdin = asyncio.subprocess.PIPE,
        stdout = asyncio.subprocess.PIPE,
        stderr = asyncio.subprocess.PIPE
    )

    print("[CLIENT] [INFO] Preparing to negotiate tunnel configuration...")

    try:
        # The tunnel configuration should be quick if all is well, so timeout
        # if it takes more than a handful of seconds
        await asyncio.wait_for(
            configure_tunnel(ssh_proc, config),
            config.tunnel_configure_timeout
        )
    except asyncio.TimeoutError:
        print("[CLIENT] [ERROR] Timed out negotiating tunnel configuration")
        # Terminate the SSH process before exiting
        # Start by sending SIGTERM
        ssh_proc.terminate()
        # If the process is still running 30s later, send SIGKILL
        try:
            await asyncio.wait_for(ssh_proc.wait(), 30)
        except asyncio.TimeoutError:
            ssh_proc.kill()
        sys.exit(1)

    print("[CLIENT] [INFO] Tunnel configured successfully")

    # Print stdout and stderr until the process finishes
    async def forward(input, output):
        while not input.at_eof():
            line = (await input.readline()).decode()
            output.write(line)
            output.flush()
    await asyncio.wait([
        asyncio.create_task(forward(ssh_proc.stdout, sys.stdout)),
        asyncio.create_task(forward(ssh_proc.stderr, sys.stderr)),
        asyncio.create_task(ssh_proc.wait())
    ])
    
    if ssh_proc.returncode == 0:
        print("[CLIENT] [INFO] SSH process exited without an error")
    else:
        print(f"[CLIENT] [WARNING] SSH process exited with non-zero exit code ({ssh_proc.returncode})")

    # Exit with the returncode from the SSH command
    sys.exit(ssh_proc.returncode)


if __name__ == "__main__":
    asyncio.run(main())
