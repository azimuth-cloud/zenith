#!/usr/bin/env python3

import contextlib
import dataclasses
import json
import os
import random
import re
import shutil
import signal
import string
import subprocess
import sys
import tempfile
import typing


@dataclasses.dataclass
class Config:
    """
    Class representing the configuration of the tunnel client.
    """
    #: The SSH executable to use
    ssh_executable: str
    #: Configure timeout
    tunnel_configure_timeout: int
    #: The tunnel server to connect to
    tunnel_server: str
    #: The tunnel server SSH port
    tunnel_server_port: int
    #: The host to forward tunnel traffic to
    forward_to_host: str
    #: The port to forward tunnel traffic to
    forward_to_port: int
    #: The subdomain to request
    #: If not given, a random subdomain is used
    subdomain: typing.Optional[str]
    #: The metadata associated with the tunnel
    metadata: typing.Dict[str, str]


@contextlib.contextmanager
def make_ssh_key():
    """
    Makes a temporary SSH key for the connection and returns the path to use
    as the identity file.

    The context manager ensures that the key is disposed off at the end.
    """
    key_directory = tempfile.mkdtemp()
    try:
        key_file = os.path.join(key_directory, "id_rsa")
        # Use a 2048-bit RSA key as it represents an acceptable compromise between speed
        # of generation and security, especially for a disposible key
        subprocess.check_call([
            "ssh-keygen",
            "-t",
            "rsa",
            "-b",
            "2048",
            "-N",
            "",
            "-C",
            "tunnel-key",
            "-f",
            key_file
        ])
        yield key_file
    except subprocess.CalledProcessError:
        print("[CLIENT] [ERROR] Failed to generate SSH key for connection", file = sys.stderr)
        sys.exit(1)
    finally:
        shutil.rmtree(key_directory)


def get_config_from_env():
    """
    Returns a config object built from the environment variables.
    """
    if 'SUBDOMAIN' in os.environ:
        subdomain = os.environ['SUBDOMAIN']
    else:
        subdomain = "".join(random.choices(string.ascii_lowercase + string.digits, k = 32))
    # We allow arbitrary metadata to be associated with the tunnel, read from
    # environment variables beginning TUNNEL_META_
    metadata = {
        re.sub(r'[^a-z0-9]+', '-', name.removeprefix("TUNNEL_META_").lower()): value
        for name, value in os.environ.items()
        if name.startswith("TUNNEL_META_")
    }
    return Config(
        ssh_executable = os.environ.get('SSH_EXECUTABLE', 'ssh'),
        # Default to a 5s timeout
        tunnel_configure_timeout = int(os.environ.get('TUNNEL_CONFIGURE_TIMEOUT', '5')),
        tunnel_server = os.environ['TUNNEL_SERVER'],
        tunnel_server_port = os.environ.get('TUNNEL_SERVER_PORT', '22'),
        forward_to_host = os.environ.get('FORWARD_TO_HOST', 'localhost'),
        forward_to_port = os.environ.get('FORWARD_TO_PORT', '8000'),
        subdomain = subdomain,
        metadata = metadata
    )


def get_allocated_port(output):
    """
    Extract the allocated port from the output stream.
    """
    for line in output:
        line = line.rstrip()
        match = re.match(r"Allocated port (?P<port>\d+) for remote forward", line)
        if match is not None:
            return int(match.group('port'))
        else:
            # If the line is not the one we need, send it to stderr
            print(line, file = sys.stderr)
    else:
        print("[CLIENT] [ERROR] No port received from server", file = sys.stderr)
        sys.exit(1)


def wait_for_marker(output, marker):
    """
    Waits for the given marker to appear on the output stream before returning.
    """
    for line in output:
        line = line.rstrip()
        if line == marker:
            break
        else:
            # If the line is not the one we need, send it to stdout
            print(line)
    else:
        print(f"[CLIENT] [ERROR] Unable to find marker '{marker}'", file = sys.stderr)
        sys.exit(1)


def raise_timeout_error(signum, frame):
    """
    Utility function to raise a timeout error, used as a signal handler for the alarm signal.
    """
    raise TimeoutError


@contextlib.contextmanager
def timeout(seconds):
    """
    Context manager / decorator that imposes a timeout on the wrapped code.
    """
    previous = signal.signal(signal.SIGALRM, raise_timeout_error)
    signal.alarm(seconds)
    try:
        yield
    finally:
        signal.alarm(0)
        signal.signal(signal.SIGALRM, previous)


def configure_tunnel(ssh_proc, config):
    """
    Configures the tunnel.
    """
    # If the server is behaving correctly configuring the tunnel should be quick,
    # so we should time out if it takes too long
    try:
        with timeout(config.tunnel_configure_timeout):
            # Get the dynamically allocated port from the SSH process
            # This is received on stdout, but we have configured the process to send
            # stderr to stdout
            allocated_port = get_allocated_port(ssh_proc.stdout)
            # Build the config object
            tunnel_config = dict(
                allocated_port = allocated_port,
                subdomain = config.subdomain,
                metadata = config.metadata
            )
            # The server will ask for the config when it is ready
            wait_for_marker(ssh_proc.stdout, "SEND_CONFIGURATION")
            # Then we send a JSON-encoded version of the configuration
            json.dump(tunnel_config, ssh_proc.stdin)
            # We need to send a newline to trigger the read on the server
            print("", file = ssh_proc.stdin)
            # Indicate that we have sent all the configuration that we will send
            print("END_CONFIGURATION", file = ssh_proc.stdin)
            ssh_proc.stdin.flush()
            #Â Wait for the server to confirm that it received the config
            wait_for_marker(ssh_proc.stdout, "RECEIVED_CONFIGURATION")
            print("[CLIENT] [INFO] Tunnel configured successfully")
    except TimeoutError:
        print(
            "[CLIENT] [ERROR] Timed out negotiating tunnel configuration",
            file = sys.stderr
        )
        # Terminate the SSH process before exiting
        ssh_proc.terminate()
        sys.exit(1)


def forward_stream(input, output):
    """
    Reads input from the input stream and writes it to the output stream.
    """
    for line in input:
        print(line, file = output)


def main():
    """
    Entry point for the script.
    """
    with make_ssh_key() as ssh_identity_path:
        # Build the config object from the environment
        config = get_config_from_env()

        # Derive the SSH command to use from the configuration
        ssh_command = [
            config.ssh_executable,
            # Force a TTY so that we can send data over stdin
            "-tt",
            # Exit immediately if the port forwarding fails
            "-o",
            "ExitOnForwardFailure=yes",
            # Ignore host keys (for now)
            "-o",
            "StrictHostKeyChecking=no",
            "-o",
            "UserKnownHostsFile=/dev/null",
            # Use the generated authorized key to authenticate
            "-o",
            "IdentitiesOnly=yes",
            "-i",
            ssh_identity_path,
            # Use a dynamically allocated port
            "-R",
            f"0:{config.forward_to_host}:{config.forward_to_port}",
            # Configure the tunnel server
            "-p",
            config.tunnel_server_port,
            f"tunnel@{config.tunnel_server}",
        ]

        print(f"[CLIENT] [INFO] Spawning SSH - {' '.join(ssh_command)}")

        # Open the SSH process
        ssh_proc = subprocess.Popen(
            ssh_command,
            text = True,
            stdin = subprocess.PIPE,
            stdout = subprocess.PIPE,
            # Send stderr to the same handler as stdout
            stderr = subprocess.STDOUT
        )

        print("[CLIENT] [INFO] Preparing to negotiate tunnel configuration...")

        configure_tunnel(ssh_proc, config)

        # Just forward stdout (which contains stderr) until the process exits
        for line in ssh_proc.stdout:
            print(line.rstrip())

        # Belt and braces to make sure the process has definitely terminated
        ssh_proc.wait()

        if ssh_proc.returncode == 0:
            print("[CLIENT] [INFO] SSH process exited without an error")
        else:
            print(
                f"[CLIENT] [WARNING] SSH process exited with non-zero exit code ({ssh_proc.returncode})",
                file = sys.stderr
            )

        # Exit with the returncode from the SSH command
        sys.exit(ssh_proc.returncode)


if __name__ == "__main__":
    main()
