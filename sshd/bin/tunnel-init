#!/usr/bin/env python3

####
# This script runs when a user connects over SSH, and is responsible for
# registering the mapping of a subdomain to the port for a reverse SSH tunnel
# with Consul.
#
# The client specifies the bound port and subdomain using stdin.
#
# We would prefer to detect the bound port for the tunnel on this side but
# doing this reliably might be impossible, and is certainly very difficult
# and probably requires root.
#
# To get round this, the client reads the tunnel's dynamically-allocated port
# from stderr and pushes it back via stdin along with the subdomain.
#
# This obviously places a lot of trust in a client to specify the SSH
# connection correctly, and also to specify the actual port it was allocated
# rather than a different port that another service may be connected to.
#
# We mitigate against this in a number of ways:
#
#   1. Only allow the execution of this script over the SSH connection. This
#      limits the ability of a nefarious client to collect information about
#      other tunnels connected to the system and their ports.
#
#   2. Encourage clients to use dynamically-allocated ports. This makes the
#      port for a service more difficult to guess and so harder to connect
#      to for nefarious purposes.
#
#   3. Encourage clients to use subdomains that are hard to guess.
#      This makes it more difficult for a nefarious client to discover a valid
#      domain and bind to it.
#
#   4. Only allow ports to be bound to localhost. This prevents a nefarious user
#      from accessing the bound port directly, bypassing the proxy and any
#      associated authentication.
#
#   5. Only allow reverse port-forwarding, not regular port-forwarding. This
#      prevents a nefarious client from setting up a regular port-foward to
#      the bound port for another service and sending traffic directly to it,
#      bypassing the proxy and any associated authentication.
#
# CORRECT USAGE
#
# The correct usage of this tunnel server would look something like:
#
#   $ ssh -t -o ExitOnForwardFailure=yes -R 0:localhost:8000 tunnel@<tunnelhost>
#   [stderr] Allocated port 43627 for remote forward to localhost:8000
#   [stdout] Reading configuration from stdin...
#   [stdout] SET_PORT
#   [STDIN]  43627           <-- Corresponds to allocated port
#   [stdout] SET_SUBDOMAIN
#   [STDIN]  b103b6ae7f13d66d4fedeac0794160ca
#
# This would allocate the specified subdomain to the bound port.
#
# ATTEMPTING TO SEND UNAUTHENTICATED TRAFFIC DOWN A REGULAR PORT-FORWARD
#
# If a nefarious client wanted to send traffic directly to the above service and
# not via the proxy in order to bypass authentication, and was able to discover
# the bound port number, they might try something like:
#
#          Try to open a forwarded port to the service's port
#                                |
#   $ ssh -N -L 5000:localhost:43627 tunnel@<tunnelhost>
#
# However any attempt to send traffic down this tunnel results in multiple
# messages like the following, and a reset connection:
#
#   channel 3: open failed: administratively prohibited: open failed
#   channel 4: open failed: administratively prohibited: open failed
#   ...
####

import dataclasses
import os
import signal
import sys
import time
import uuid

import requests


@dataclasses.dataclass
class Config:
    """
    Object representing the configuration for the tunnel.
    """
    #: The URL of the consul server to register services with
    consul_url: str
    #: The time between heartbeats
    consul_heartbeat_interval: int
    #: The ID of the service, unique to this tunnel
    service_id: str
    #: The host for the service (the external IP or hostname of the host running the script)
    service_host: str
    #: The port for the service (the tunnel port)
    service_port: int
    #: The subdomain to use
    subdomain: str


def parse_port(input):
    """
    Attempts to parse the given input as a port
    """
    return int(input)


def parse_subdomain(input):
    """
    Attempts to parse the given input as a subdomain.
    """
    return input


def get_config():
    """
    Returns a config object for the tunnel.
    """
    print("[SERVER] [INFO] Waiting for configuration...")
    # The port and subdomain will be fed via stdin in response to markers printed on stdout
    print("SET_PORT")
    service_port = parse_port(input())
    print(f"[SERVER] [INFO] Recieved port - {service_port}")
    print("SET_SUBDOMAIN")
    subdomain = parse_subdomain(input())
    print(f"[SERVER] [INFO] Recieved subdomain - {subdomain}")
    print("CONFIGURATION_COMPLETE")
    return Config(
        # The consul address and service host should be available as environment variables
        consul_url = f"http://{os.environ['CONSUL_HTTP_ADDR']}",
        service_host = os.environ['SERVICE_HOST'],
        # Use a default heartbeat interval, but allow it to be overridden
        consul_heartbeat_interval = int(os.environ.get('CONSUL_HEARTBEAT_INTERVAL', '10')),
        # Generate a UUID for the service that is unique to this tunnel
        service_id = str(uuid.uuid4()),
        service_port = service_port,
        subdomain = subdomain
    )


def consul_register_service(config):
    """
    Registers the service with Consul.
    """
    print("[SERVER] [INFO] Registering service with Consul...")
    # Post the service information to consul
    url = f"{config.consul_url}/v1/agent/service/register"
    response = requests.put(url, json = {
        # Use the tunnel ID as the unique id
        "ID": config.service_id,
        # Use the specified subdomain as the service name
        "Name": config.subdomain,
        # Use the service host and port as the address and port in Consul
        "Address": config.service_host,
        "Port": config.service_port,
        # Specify a TTL check
        "Check": {
            # Use the unique ID for the tunnel as the check id
            "CheckId": config.service_id,
            "Name": "tunnel-active",
            # We will post an update every 10s
            # This means that we can afford three failed updates before
            # we move into the critical state
            # Note that we can move back to the pass state if connectivity
            # is restored
            "TTL": "30s",
            # This deregisters the service once it has been critical for 5 minutes
            # We can probably assume the service will not come back up
            "DeregisterCriticalServiceAfter": "5m",
        },
    })
    # If we failed to register the service then bail
    if 200 <= response.status_code < 300:
        print("[SERVER] [INFO] Registered service successfully")
    else:
        print("[SERVER] [ERROR] Failed to register service", file = sys.stderr)
        sys.exit(1)


def consul_deregister_service(config):
    """
    Deregisters the service in Consul.

    We don't really care if this fails because the service will be marked critical
    after 30s and removed after 5m anyway, but this speeds up the process.
    """
    url = f"{config.consul_url}/v1/agent/service/deregister/{config.service_id}"
    response = requests.put(url)


def consul_heartbeat(config):
    """
    Updates the health check for the service to the pass state.
    """
    print("[SERVER] [INFO] Updating service health status in Consul...")
    # Post the service information to consul
    url = f"{config.consul_url}/v1/agent/check/pass/{config.service_id}"
    response = requests.put(url, params = { "note": "Tunnel active" })
    # If we failed to update the health status, emit a warning
    if 200 <= response.status_code < 300:
        print("[SERVER] [INFO] Service health updated successfully")
    else:
        print("[SERVER] [ERROR] Failed to update service health", file = sys.stderr)
        sys.exit(1)


def register_signal_handlers(config):
    """
    Registers signal handlers for each of the exit signals we care about.
    """
    def signal_handler(signum, frame):
        consul_deregister_service(config)
        sys.exit()

    signal.signal(signal.SIGALRM, signal_handler)
    # The remote end hanging up should be a SIGHUP
    signal.signal(signal.SIGHUP, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    # We deliberately ignore SIGKILL as that is meant to signal an ungraceful exit
    # It is also not supported on some platforms, e.g. OSX
    # Any well-behaved exit request should be SIGTERM


def main():
    """
    The entrypoint for this script.
    """
    config = get_config()
    consul_register_service(config)
    register_signal_handlers(config)
    # We need to send a regular heartbeat to Consul
    while True:
        consul_heartbeat(config)
        time.sleep(config.consul_heartbeat_interval)


if __name__ == "__main__":
    main()
